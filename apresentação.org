#+Title: V√¥o de P√°ssaro: Polysemy, um Sistema de Efeitos
#+Author: Thales Macedo Garitezi

#+Startup: showeverything

# ,#+REVEAL_ROOT: https://cdn.jsdelivr.net/npm/reveal.js@3.8.0
#+REVEAL_ROOT: file:///home/thales/Downloads/reveal.js-3.8.0/
#+REVEAL_THEME: black
#+REVEAL_MIN_SCALE: 0.3
#+REVEAL_MAX_SCALE: 2.5
#+REVEAL_EXTRA_CSS: ./style.css
#+OPTIONS: toc:1

* Sistemas de efeitos

** O que s√£o efeitos?

- Contexto :: programa√ß√£o funcional.
- Express√£o Pura :: transpar√™ncia referencial.
- Efeito :: modifica o estado do "mundo"

#+REVEAL: split

#+NAME: fig:st_monad_1
[[./images/st_monad_1.png]]

#+NAME: fig:st_monad_2
[[./images/st_monad_2.png]]

** Exemplos de efeitos

- Ler/escrever no terminal
- Log
- Exce√ß√µes
- Continua√ß√µes/alterar fluxo de execu√ß√£o

** Sistema de efeitos?

- Uma maneira de lidar com efeitos computacionais (/efeitos impuros/)
- Baseada na premissa de que a impureza adv√©m de um conjunto de opera√ß√µes
  - Ex: ~get~, ~set~, ~write~, ~raise~ [fn:2]
- Tamb√©m: /algebraic effects/ ou /extensible effects/.[fn:1] [fn:3]

[fn:1] http://hackage.haskell.org/package/fused-effects
[fn:2] https://www.eff-lang.org/handlers-tutorial.pdf
[fn:3] http://okmij.org/ftp/Haskell/extensible/exteff.pdf

** Para qu√™?

- Controle de efeitos colaterais.
- Separa as a√ß√µes a serem feitas (/sintaxe/) da interpreta√ß√£o (/sem√¢ntica/).
  - Facilita testes unit√°rios.
  - Desej√°vel: f√°cil composi√ß√£o.
- Tipos: controle de quais efeitos s√£o permitidos e tratados.

* "Efeitos tradicionais" em Haskell

#+BEGIN_SRC haskell
data Maybe a = Just a | Nothing -- Exce√ß√µes / nulo
data Either e a = Left e | Right a -- Exce√ß√µes com "mensagens"
data List a = Nil | Cons a (List a) -- N√£o determinismo

-- Outros exemplos: estado, log, vari√°veis de ambiente, ...
#+END_SRC

** Como comp√µem?

/Monad transformers/

#+BEGIN_SRC haskell
-- Estado + Vari√°veis de ambiente somente leitura + exce√ß√µes
ExceptT MyError (ReaderT MyEnvironment (StateT MyState IO)) a
#+END_SRC

#+REVEAL: split

Funcionamento depende fortemente da ordem de composi√ß√£o.

#+BEGIN_SRC haskell
newtype ExceptT e m a -- ~> m (Either e a)
newtype StateT s m a -- ~>  s -> m (a, s)

ExceptT e (StateT s m) a -- Mant√©m o estado no caso de exce√ß√£o
-- ~ s -> m ((Either e a), s)

StateT s (ExceptT e m) a -- Joga tudo fora se houver uma exce√ß√£o
-- ~ s -> m (Either e (a, s))
#+END_SRC

#+REVEAL: split

Vide [[./src/ExMTL.hs]]

#+REVEAL: split

- Existe tamb√©m o estilo MTL (/Monad Transformer Library/)
- Usa /Typeclasses/
- Problema: n√∫mero grande de re-implementa√ß√µes de classes para cada monad novo que usa.

#+REVEAL: split

Outros problemas:
- Dificuldade em testar.
  - Precisa implementar mais v√°rias inst√¢ncias para emular os efeitos...
- Dificuldade / impossibilidade de usar m√∫ltiplas inst√¢ncias do mesmo efeito (m√∫ltiplos ambientes somente leitura, exce√ß√µes, ...)

* Sistema de efeitos

- Costumam ser implementados como bibliotecas.
- Algumas linguagens t√™m foco em efeitos algebraicos.
  - Ex: Koka[fn:4], Eff[fn:5], OCaml (?)[fn:6]

[fn:4] https://www.eff-lang.org/
[fn:5] https://www.microsoft.com/en-us/research/project/koka/
[fn:6] https://github.com/ocaml-multicore/ocaml-multicore/wiki

** (Pseudo-)Exemplo: A√ß√µes

#+BEGIN_SRC haskell
example :: Members '[ Log String
                    , KVStore
                    , Output String
                    , Input String
                    ]
                    r -- Pode conter mais efeitos
        => Sem r ()
example = do
  log "Starting up..."
  writeTTY "Please enter your name and age:"
  [name, age] <- words <$> readTTY
  log "Writing data to store..."
  putKV name age
  writeTTY ("Welcome, " <> name <> "!")
#+END_SRC

** (Pseudo-)Exemplo: Interpreta√ß√µes

#+BEGIN_SRC haskell
runInputList :: [i]
             -> Sem (Input (Maybe i) ': r) a
             -> Sem r a
runOutputList :: forall o r a. Sem (Output o ': r) a
              -> Sem r ([o], a)
runKVStoreMap :: Map String String
              -> Sem (Database ': r)
              -> Sem r (Map String String)
...

runMyExamplePure inputs emptyMap
  = runInputList inputs
  . runOutputList
  . runKVStoreMap emptyMap
  ...
#+END_SRC

* Bibliotecas de Efeitos em Haskell

- ~fused-effects~
- ~freer-simple~
- Free Monads

* Polysemy

#+NAME: img:polysemy_logo
[[./images/polysemy.png]]

#+REVEAL: split

- /It's like mtl but composes better, requires less boilerplate, and avoids the O(n^2) instances problem./
- /It's like freer-simple but more powerful and 35x faster./
- /It's like fused-effects but with an order of magnitude less boilerplate./

/Additionally, unlike mtl, polysemy has no functional dependencies, so you can use multiple copies of the same effect./

https://github.com/polysemy-research/polysemy

** Exemplos

[[./src/Ex1.hs]]

[[./src/Ex2.hs]]

** Mais um exemplo

https://github.com/KerfuffleV2/haskell-polysemy-test/blob/3ba61c17f6ff8b91b2cf789deb87ec6e2884bcdb/src/example3/Main.hs

* Limita√ß√µes

- Ainda n√£o √© o mais otimizado poss√≠vel.
- Mais passes de otimiza√ß√£o no Core.
- Precisar√° de:
  - GHC 8.10.1
  - Precisa de ~import Polysemy~ nos arquivos que quiser otimizar.
  - Flags do GHC: ~-O2 -flate-specialize -fplugin=Polysemy.Plugin~

* Tufe

#+BEGIN_CENTER
üç∫
#+END_CENTER
